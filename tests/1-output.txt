You do it by turning the LLM into a *multiâ€‘step compressor* and _never_ feeding it more text than fits at once\.

Below is a concrete recipe, written so you can implement it\.

â€”â€”â€”â€”â€”â€”â€”â€”

*â­ 1\. What Youâ€™re Trying To Achieve*

Given:

â¦ A long conversation: a list like  
  `messages \= \[\{role: "user"\|"assistant", content: string\}, â€¦\]`
â¦ An LLM with a fixed context limit \(token budget\), e\.g\. 8k / 16k / 32k / 128k tokens\.
You want to:
â¦ Produce a *summary of the whole conversation* that fits in the LLMâ€™s context, and/or
â¦ Keep chatting with the user while the LLM still has access to relevant past information, *even after* the raw history no longer fits\.
You cannot just send the whole conversation; instead you:

â¦ *Split* it into chunks that fit;
â¦ *Summarize* each chunk using the LLM;
â¦ Optionally *summarize those summaries* \(hierarchical\);
â¦ Maintain a *small â€œmemoryâ€* object that represents the past\.

â€”â€”â€”â€”â€”â€”â€”â€”

*â­ 2\. Set Explicit Token Budgets*

You must pick explicit numbers, not guess\.

Assume:

â¦ `MODEL\_CONTEXT\_TOKENS` \= max tokens your LLM can accept \(say 16,000\)\.
Define:

â¦ `MAX\_CHUNK\_TOKENS` â€” maximum tokens of _conversation text_ you send in a _single summarization_ call\.  
  Example: `MAX\_CHUNK\_TOKENS \= 3\_000`\.
â¦ `TARGET\_CHUNK\_SUMMARY\_TOKENS` â€” target size of each firstâ€‘level summary\.  
  Example: `300`\.
â¦ `TARGET\_GROUP\_SUMMARY\_TOKENS` â€” target size of each higherâ€‘level summary\.  
  Example: `400`\.
â¦ `TARGET\_GLOBAL\_SUMMARY\_TOKENS` â€” target size of final conversation summary\.  
  Example: `800â€“1\_200`\.
For ongoing chat, also:

â¦ `MEMORY\_TOKEN\_LIMIT` â€” max size of longâ€‘term memory\.  
  Example: `600`\.
â¦ `RECENT\_WINDOW\_TOKEN\_LIMIT` â€” how many tokens of raw â€œrecentâ€ conversation you aim to keep\.  
  Example: `3\_000`\.
Use the modelâ€™s tokenizer \(e\.g\. `tiktoken`\) to write:

```text
token\_count\(text\) \-\> approximate token count
```

Everything else will rely on this\.

â€”â€”â€”â€”â€”â€”â€”â€”

*â­ 3\. Offline: Summarize an Existing Long Conversation*
*ğŸ”¸ğŸ”¸ 3\.1\. Step 1 â€“ Chunk the Conversation*

Input:

```text
messages \= \[
  \{role: "user", content: "\.\.\."\},
  \{role: "assistant", content: "\.\.\."\},
  \.\.\.
\]
```

Goal: `chunks\[\]`, where each `chunk` is a list of messages whose total tokens â‰¤ `MAX\_CHUNK\_TOKENS`\.

Pseudocode:

```pseudo
function chunk\_messages\(messages, max\_chunk\_tokens\):
    chunks \= \[\]
    current\_chunk \= \[\]
    current\_tokens \= 0

    for msg in messages:
        text \= msg\.role \+ ": " \+ msg\.content
        t \= token\_count\(text\)

        if t \> max\_chunk\_tokens:
            \# Edge case: single message is longer than allowed\.
            \# Summarize this one separately instead of putting it raw in a chunk\.
            summary \= summarize\_single\_long\_message\_with\_llm\(msg\)
            chunks\.append\(\[
                \{role: "assistant", content: "\(summary of long message\) " \+ summary\}
            \]\)
            continue

        if current\_tokens \+ t \> max\_chunk\_tokens and current\_chunk not empty:
            chunks\.append\(current\_chunk\)
            current\_chunk \= \[msg\]
            current\_tokens \= t
        else:
            current\_chunk\.append\(msg\)
            current\_tokens \+\= t

    if current\_chunk not empty:
        chunks\.append\(current\_chunk\)

    return chunks
```

Notes:

â¦ You always cut at *message boundaries*\.
â¦ `summarize\_single\_long\_message\_with\_llm` is just a oneâ€‘off â€œsummarize this textâ€ call\.

â€”â€”â€”â€”â€”â€”â€”â€”

*ğŸ”¸ğŸ”¸ 3\.2\. Step 2 â€“ Summarize Each Chunk with the LLM*

For each chunk, call the LLM with a strict summarization prompt\.

*ğŸ”¸ Prompt template \(per chunk, copyâ€‘paste\):*

>
>You are summarizing a segment of a long conversation between a user and an assistant\.
>
>Your goal is to produce a short but highly informative summary that can replace the raw messages in future prompts\.===>
>*INCLUDE \(only if present and important\):*
>
>â¦ Main user questions, tasks, and goals in this segment
>â¦ Important facts, constraints, and preferences the user states \(deadlines, environment, skill level, likes/dislikes, etc\.\)
>â¦ Key explanations, designs, solution ideas, and reasoning from the assistant \(described concisely in words; avoid large code blocks\)
>â¦ Any decisions made, final answers given, or conclusions reached
>â¦ Any explicit open questions or TODO items mentioned
>
>*EXCLUDE OR MINIMIZE:*
>
>â¦ Greetings, small talk, and filler conversation
>â¦ Repetitive text that adds no new information
>â¦ Very lowâ€‘level intermediate steps or details unlikely to matter later
>*OUTPUT FORMAT \(plain text, no JSON, no code fences\):*
>
>â¦ Topics: bullet list of the main topics discussed\.
>
>â¦ User Goals: bullet list of what the user wanted or asked for in this segment\.
>â¦ Key Facts: bullet list of important facts, constraints, or preferences\.
>â¦ Assistant Actions: bullet list describing what the assistant did \(explained X, proposed Y, wrote code for Z, etc\.\)\.
>â¦ Decisions / Outcomes: bullet list of any conclusions, solutions, or decisions reached\.
>
>â¦ Open Questions / TODOs: bullet list of unresolved issues or future steps\.
>*LENGTH LIMIT:*
>
>â¦ Maximum 300 tokens\. Be concise and informationâ€‘dense\.
>Now summarize the following conversation segment:
>
>\[BEGIN SEGMENT\]  
>
><insert this chunkâ€™s messages, each prefixed with â€œuser:â€ or â€œassistant:â€\>  
>\[END SEGMENT\]
>

>
Codeâ€‘ish:

```pseudo
chunk\_summaries \= \[\]

for i, chunk in enumerate\(chunks\):
    prompt \= build\_chunk\_summary\_prompt\(chunk\)  \# uses text above
    summary\_text \= call\_llm\(prompt\)
    chunk\_summaries\.append\(\{
        "chunk\_index": i,
        "summary": summary\_text
    \}\)
```

Now the entire long conversation is represented by, say, 50â€“200 chunk summaries\.

â€”â€”â€”â€”â€”â€”â€”â€”

*ğŸ”¸ğŸ”¸ 3\.3\. Step 3 â€“ Summarize the Summaries \(Hierarchy\)*

If all `chunk\_summaries` together are still too big for your use case, compress them again\.

*ğŸ”¸ 3\.3\.1\. Group summaries*

Choose `group\_size` so that `group\_size \* TARGET\_CHUNK\_SUMMARY\_TOKENS` fits comfortably under `MAX\_CHUNK\_TOKENS`\.

Example: if chunk summaries â‰ˆ300 tokens, `group\_size \= 10` â‡’ \~3000 tokens of input\.

```pseudo
group\_size \= 10
groups \= \[\]
for i in range\(0, len\(chunk\_summaries\), group\_size\):
    groups\.append\(chunk\_summaries\[i : i \+ group\_size\]\)
```

Each `group` will be converted into a higherâ€‘level summary\.

*ğŸ”¸ 3\.3\.2\. Prompt to compress a group of summaries:*

>
>You are compressing multiple conversation summaries into a more compact higherâ€‘level summary\.
>
>*INPUT:*  
>A list of summaries, in chronological order, each summarizing a segment of a long userâ€“assistant conversation\.
>
>*GOAL:*
>
>
>â¦ Merge overlapping and redundant information\.
>â¦ Preserve important, persistent information about:
>â¦ user goals, preferences, constraints, and profile
>â¦ key facts and data
>â¦ main solution ideas, designs, or strategies
>â¦ important decisions and outcomes
>â¦ longâ€‘running tasks or projects and their progress
>â¦ important unresolved questions or TODOs
>â¦ Provide a sense of how the conversation evolved across these segments\.
>*OUTPUT FORMAT \(plain text, no JSON\):*
>
>â¦ Highâ€‘Level Themes: bullet list of dominant themes/topics across all segments\.
>â¦ Timeline / Phases: numbered list where each item briefly describes a phase \(what the user wanted, what the assistant did, key changes or progress\)\.
>â¦ Persistent User Info: bullet list of stable user profile info or preferences seen here\.
>â¦ Key Decisions / Facts: bullet list of core facts, designs, or decisions that remain important\.
>â¦ Open Issues / TODOs: bullet list of unresolved questions or tasks left after these segments\.
>*LENGTH LIMIT:*
>
>â¦ Maximum 400 tokens\. Aggressively remove repetition and lowâ€‘value detail\.===>Now compress the following summaries into one higherâ€‘level summary:
>
>\[BEGIN SUMMARIES\]  
>
><insert the chunk summaries here, separated and in order\>  
>\[END SUMMARIES\]

Pseudocode:

```pseudo
group\_summaries \= \[\]

for group in groups:
    prompt \= build\_multi\_summary\_prompt\(group\)
    summary\_text \= call\_llm\(prompt\)
    group\_summaries\.append\(summary\_text\)
```

If the list `group\_summaries` is still too long in total:

â¦ Treat `group\_summaries` as the new â€œchunk\_summariesâ€\.
â¦ Repeat: group them, compress again\.
â¦ Continue until you can fit everything into *one global summary* of â‰¤ `TARGET\_GLOBAL\_SUMMARY\_TOKENS`\.

â€”â€”â€”â€”â€”â€”â€”â€”

*ğŸ”¸ğŸ”¸ 3\.4\. Step 4 â€“ Convert Global Summary into a Reusable â€œMemoryâ€*

Now you have a global textual summary\. Turn it into a small, structured memory object\.

*ğŸ”¸ Prompt: global summary â†’ longâ€‘term memory*

>
>You are constructing a compact longâ€‘term memory from a global summary of a userâ€“assistant conversation\.
>
>*INPUT:*  
>A highâ€‘level summary of the entire conversation\.
>
>*TASK:*  
>Convert this into a structured memory that contains only information likely to be useful in future conversation turns\.
>
>Focus on:
>
>â¦ Who the user is \(skills, preferences, constraints, relevant background\)
>â¦ Main projects, tasks, or topics and their status
>â¦ Important decisions, conclusions, designs, or facts that should not be forgotten
>
>â¦ Unresolved questions or TODOs that might be revisited later
>Ignore:
>
>â¦ Transient details, minor side comments, throwaway examples, and small talk
>*OUTPUT FORMAT \(plain text, no JSON\):*
>â¦ User Profile: bullet list of what we know about the user \(skills, preferences, constraints, etc\.\)\.
>â¦ Projects / Topics: bullet list of the main projects or topics and their current status\.
>â¦ Key Decisions / Facts: bullet list of core facts, designs, or conclusions that matter later\.
>
>â¦ Open Questions / TODOs: bullet list of unresolved issues or planned next steps\.
>*LENGTH LIMIT:*
>
>â¦ Maximum 600 tokens\. Be very selective and concise\.
>
>Now produce the longâ€‘term memory from the following summary:
>
>\[BEGIN HIGHâ€‘LEVEL SUMMARY\]  
><insert your final global summary\>  
>\[END HIGHâ€‘LEVEL SUMMARY\]

The modelâ€™s output is your `long\_term\_memory` string: a compressed representation of the entire conversation that you can reâ€‘inject into future prompts\.

â€”â€”â€”â€”â€”â€”â€”â€”

*â­ 4\. Online: Keep Summarizing As You Chat*

When conversation keeps growing, you need a *rolling* solution:

â¦ Maintain:
â¦ a small `long\_term\_memory` \(bounded text\), and
â¦ a list of `recent\_messages` \(raw most recent turns\)\.
*ğŸ”¸ğŸ”¸ 4\.1\. State*

```pseudo
state \= \{
    "long\_term\_memory": "",  \# string, â‰¤ MEMORY\_TOKEN\_LIMIT
    "recent\_messages": \[\]    \# list of \{role, content\}
\}
```

*ğŸ”¸ğŸ”¸ 4\.2\. On Every New User Message*

Algorithm:

```pseudo
function handle\_user\_message\(user\_text\):
    \# 1\. Add new user message
    state\.recent\_messages\.append\(\{role: "user", content: user\_text\}\)

    \# 2\. See how big the prompt would be if we include memory \+ all recent messages
    prompt \= build\_answer\_prompt\(
        long\_term\_memory \= state\.long\_term\_memory,
        recent\_messages \= state\.recent\_messages
    \)
    used\_tokens \= token\_count\(prompt\)

    \# 3\. If context is getting large, compress older part of recent\_messages
    if used\_tokens \> MODEL\_CONTEXT\_TOKENS \* 0\.7:
        old\_segment \= select\_old\_segment\(state\.recent\_messages\)
        if old\_segment not empty:
            segment\_summary \= summarize\_segment\(old\_segment\)  \# same chunk\-summary prompt, but on this segment
            \# Remove old\_segment from recent\_messages
            state\.recent\_messages \= state\.recent\_messages \- old\_segment
            \# Merge new summary into long\_term\_memory
            state\.long\_term\_memory \= update\_memory\(===                current\_memory \= state\.long\_term\_memory,
                new\_summary \= segment\_summary
            \)

    \# 4\. Build final prompt using updated memory \+ remaining recent messages
    prompt \= build\_answer\_prompt\(
        long\_term\_memory \= state\.long\_term\_memory,
        recent\_messages \= state\.recent\_messages
    \)

    \# 5\. Ask LLM for the reply
    assistant\_reply \= call\_llm\(prompt\)

    \# 6\. Store reply as part of recent\_messages
    state\.recent\_messages\.append\(\{role: "assistant", content: assistant\_reply\}\)

    return assistant\_reply
```

*ğŸ”¸ğŸ”¸ 4\.3\. Selecting Which Old Messages to Summarize*

Simple policy:
â¦ Always keep the last `K` messages raw,
â¦ Summarize everything older, up to a token limit\.
```pseudo
function select\_old\_segment\(recent\_messages\):
    keep\_last\_turns \= 8  \# keep last 8 turns uncompressed

    if length\(recent\_messages\) <\= keep\_last\_turns:
        return \[\]

    candidates \= recent\_messages\[0 : \-keep\_last\_turns\]

    \# Now trim candidates to, say, 2000 tokens\.
    old\_segment \= trim\_messages\_to\_token\_limit\(candidates, limit \= 2000\)

    return old\_segment
```

`summarize\_segment\(old\_segment\)` just reuses the chunk summarization prompt, but applied to `old\_segment`\.

â€”â€”â€”â€”â€”â€”â€”â€”

*ğŸ”¸ğŸ”¸ 4\.4\. Updating Memory Using the LLM*

You merge `segment\_summary` into existing `long\_term\_memory` with another LLM call\.

*ğŸ”¸ Prompt: update memory*

>
>You maintain a longâ€‘term memory for a userâ€“assistant conversation\.
>
>CURRENT\_MEMORY:  
><insert current long\_term\_memory\>
>
>NEW\_INFORMATION \(summary of a recent conversation segment\):  
><insert segment\_summary\>
>
>*TASK:*  
>Update CURRENT\_MEMORY so that it:
>â¦ Adds any new, important longâ€‘term information from NEW\_INFORMATION\.
>â¦ Updates or corrects information that has clearly changed\.
>â¦ Optionally removes or shrinks details that are now obsolete or clearly unimportant\.
>
>Focus on:
>â¦ Persistent user preferences, constraints, and profile info
>â¦ Onâ€‘going projects, tasks, or topics and their updated status
>â¦ Important decisions, designs, or conclusions that will matter later
>â¦ Open questions or TODOs that might be revisited
>
>Ignore or minimize:
>â¦ Transient details, oneâ€‘off examples, and minor small talk
>
>*OUTPUT:*  
>Return the UPDATED\_MEMORY only, in this structure \(plain text\):
>â¦ User Profile
>â¦ Projects / Topics
>â¦ Key Decisions / Facts
>â¦ Open Questions / TODOs
>
>*LENGTH LIMIT:*
>â¦ Maximum 600 tokens\. Compress aggressively and drop lowâ€‘importance details if necessary\.

Implementation:

```pseudo
function update\_memory\(current\_memory, new\_summary\):
    prompt \= build\_update\_memory\_prompt\(current\_memory, new\_summary\)
    updated \= call\_llm\(prompt\)
    return updated
```

This keeps `long\_term\_memory`:
â¦ Under `MEMORY\_TOKEN\_LIMIT`, and
â¦ Reflecting the whole conversation so far\.

â€”â€”â€”â€”â€”â€”â€”â€”

*ğŸ”¸ğŸ”¸ 4\.5\. Building the Actual Prompt for Answers*

To let the LLM answer the user using compressed history:

```pseudo
function build\_answer\_prompt\(long\_term\_memory, recent\_messages\):
    text \= ""
    text \+\= "SYSTEM: You are an AI assistant\. You have access to a summarized long\-term memory of the user and our past conversation\. Use it when relevant, but do not invent details that are not present in the memory or the recent messages\.\\n\\n"

    if long\_term\_memory is not empty:
        text \+\= "\[LONG\-TERM MEMORY\]\\n"
        text \+\= long\_term\_memory \+ "\\n\\n"

    text \+\= "\[RECENT CONVERSATION\]\\n"
    for msg in recent\_messages:
        text \+\= msg\.role \+ ": " \+ msg\.content \+ "\\n"

    return text
```

You send this \(or an equivalent structured version\) as context to the LLM, ensure `token\_count\(text\)` \+ expected answer length â‰¤ `MODEL\_CONTEXT\_TOKENS`, and youâ€™re good\.

â€”â€”â€”â€”â€”â€”â€”â€”

*â­ 5\. Core Rules to Remember*===â¦ *Never send the full raw conversation once itâ€™s large\.*  
  Always send:
â¦ A compressed longâ€‘term memory,
â¦ A recent window of raw messages\.
â¦ *Use the LLM in several passes:*
â¦ Chunkâ€‘level summarization,
â¦ Hierarchical compression \(if needed\),
â¦ Memory creation,
â¦ Memory updates\.
â¦ *Prompts must be explicit and structured\.*  
  Say exactly:
â¦ What to keep \(goals, constraints, facts, decisions, open questions\),
â¦ What to drop \(small talk, repetition, incidental details\),
â¦ How long the output can be\.
â¦ *Always hardâ€‘cap memory size\.*  
  Reâ€‘compress memory when it gets large by feeding it back into an â€œupdate/compress yourselfâ€ prompt\.
â¦ *Summarize earlier, not at the last second\.*  
  Start summarizing when context is around 60â€“70% full, leaving breathing room\.

â€”â€”â€”â€”â€”â€”â€”â€”


If you tell me:
â¦ Which model youâ€™re actually using \(and its context length\),
â¦ What language youâ€™re coding in,
I can translate this into nearâ€‘ready code with real functions and approximate numeric values filled in\.